Y<-Y/rowSums(Y)
return(Y)
}
gradL<-function(eta,x,y,m ){
y<-as.matrix(y)
dimeta<-m*(dim(x)[2]+1)+2*(1+m)
gradf<-rep(NA,dimeta)
Y<-NN(x,eta,m)
ETA<-eta
logl<-sum( (1-y)*log(Y[,1]) + ( y)*log(Y[,2])  )
for( i in 1:dimeta){
ETA[i]<-eta[i]+(10^-6)
Yp<-NN(x,ETA,m)
gradf[i]<-(sum( (1-y)*log(Yp[,1]) + ( y)*log(Yp[,2])  ) - logl  ) / (10^-6)	}
return(gradf)
}
Alpha<-c(-3.7748365, 2.1178734, 0.3139542, -5.5415006, -.5958018, 5.8168459, 11.0561352, 0.2074085, 14.0207743, 25.2868297, 16.0428078, 3.8300725, 15.9792114, 23.4815794, 23.2210775, -13.5097426, -12.2073593, -18.6510642, -27.0546378, -27.4979835, 15.2350215, 14.7081561)
source("multiplot.R")
#Alpha is eta (alphas and betas)
Alpha
x1<-matrix(4*runif(10000 )-2, 5000,2)
test<-as.data.frame((NN(x1,Alpha ,4)))
test<-cbind(test,x1)
test$y1<- ifelse( test[,1]>.5 , 0,1)
test$y2<- ifelse( test[,1]>.7 , 0,1)
test$y3<- ifelse( test[,1]>.3 , 0,1)
names(test)[3:4]<-c("x1","x2")
p1 <- ggplot(test, aes(x1, x2)) + geom_point(aes(colour = factor(y1))) +
ylim(-2.5, 2.5) + xlim( -2.5,2.5 ) + ggtitle("p = 0.5")
p2 <- ggplot(test, aes(x1, x2)) + geom_point(aes(colour = factor(y2))) +
ylim(-2.5, 2.5) + xlim( -2.5,2.5 ) + ggtitle("p = 0.7")
p3 <- ggplot(test, aes(x1, x2)) + geom_point(aes(colour = factor(y3))) +
ylim(-2.5, 2.5) + xlim( -2.5,2.5 ) + ggtitle("p = 0.3")
p<- p + ggtitle("original data")
multiplot(p1, p2, p3,p,  cols=2)
PlogL<-function(x,y,eta,m,rho){
X<-as.matrix(x)
ALPHA<-matrix(eta[1:prod( c(dim(X)[2] + 1, m ) )], dim(X)[2] + 1 , m)
Beta<-matrix(eta[(prod( c(dim(X)[2] + 1, m ) )+1):length(eta)],
m+1,2)
ALPHA<-as.vector(t(ALPHA[-1 ,])) ;Beta<-as.vector(t(Beta[-1 ,]))
Y<-NN(x,eta,m)
return( sum( (1-y)*log(Y[,1]) + ( y)*log(Y[,2])  ) -
rho*(sum(Norm(ALPHA)^2)+sum(Norm(Beta)^2) )
)	}
blerg<-read.csv("G:/math/504/a01.csv")
Alpha<-blerg[,1];Alpha
x1<-matrix(4*runif(10000 )-2, 5000,2)
test<-as.data.frame((NN(x1,Alpha ,4)))
test<-cbind(test,x1)
test$y1<- ifelse( test[,1]>.5 , 0,1)
test$y2<- ifelse( test[,1]>.7 , 0,1)
test$y3<- ifelse( test[,1]>.3 , 0,1)
names(test)[3:4]<-c("x1","x2")
p1 <- ggplot(test, aes(x1, x2)) + geom_point(aes(colour = factor(y1))) +
ylim(-2.5, 2.5) + xlim( -2.5,2.5 ) + ggtitle("p = 0.5")
p2 <- ggplot(test, aes(x1, x2)) + geom_point(aes(colour = factor(y2))) +
ylim(-2.5, 2.5) + xlim( -2.5,2.5 ) + ggtitle("p = 0.7")
p3 <- ggplot(test, aes(x1, x2)) + geom_point(aes(colour = factor(y3))) +
ylim(-2.5, 2.5) + xlim( -2.5,2.5 ) + ggtitle("p = 0.3")
multiplot(p1, p2, p3,  p,cols=2)
blerg<-read.csv("G:/math/504/a01.csv")
Alpha<-blerg[,2];Alpha
x1<-matrix(4*runif(10000 )-2, 5000,2)
test<-as.data.frame((NN(x1,Alpha ,4)))
test<-cbind(test,x1)
test$y1<- ifelse( test[,1]>.5 , 0,1)
test$y2<- ifelse( test[,1]>.7 , 0,1)
test$y3<- ifelse( test[,1]>.3 , 0,1)
names(test)[3:4]<-c("x1","x2")
p1 <- ggplot(test, aes(x1, x2)) + geom_point(aes(colour = factor(y1))) +
ylim(-2.5, 2.5) + xlim( -2.5,2.5 ) + ggtitle("p = 0.5")
p2 <- ggplot(test, aes(x1, x2)) + geom_point(aes(colour = factor(y2))) +
ylim(-2.5, 2.5) + xlim( -2.5,2.5 ) + ggtitle("p = 0.7")
p3 <- ggplot(test, aes(x1, x2)) + geom_point(aes(colour = factor(y3))) +
ylim(-2.5, 2.5) + xlim( -2.5,2.5 ) + ggtitle("p = 0.3")
multiplot(p1, p2, p3,  p, cols=2)
blerg<-read.csv("G:/math/504/a01.csv")
Alpha<-blerg[,2];Alpha
x1<-matrix(4*runif(10000 )-2, 5000,2)
test<-as.data.frame((NN(x1,Alpha ,4)))
test<-cbind(test,x1)
test$y1<- ifelse( test[,1]>.5 , 0,1)
test$y2<- ifelse( test[,1]>.7 , 0,1)
test$y3<- ifelse( test[,1]>.3 , 0,1)
names(test)[3:4]<-c("x1","x2")
p1 <- ggplot(test, aes(x1, x2)) + geom_point(aes(colour = factor(y1))) +
ylim(-2.5, 2.5) + xlim( -2.5,2.5 ) + ggtitle("p = 0.5")
p2 <- ggplot(test, aes(x1, x2)) + geom_point(aes(colour = factor(y2))) +
ylim(-2.5, 2.5) + xlim( -2.5,2.5 ) + ggtitle("p = 0.7")
p3 <- ggplot(test, aes(x1, x2)) + geom_point(aes(colour = factor(y3))) +
ylim(-2.5, 2.5) + xlim( -2.5,2.5 ) + ggtitle("p = 0.3")
multiplot(p1, p2, p3, p,  cols=2)
nn.fit<-glm(y~.,data = nn, family = "binomial")
logclass<-cbind(nn,predict(nn.fit,type="response"))
pi<-c(.25, .5, .75);plist<-list()
for( i in 1:3){
logclass$yhat<-ifelse( logclass[,4] < pi[i] , 0,1)
p <- ggplot(logclass, aes(x1, x2)) + geom_point(aes(colour = factor(yhat)))
plist[[i]]<- p +	stat_function(fun=function(x){ -(0.2447 /0.2031 ) -(0.0186*x/0.2031 ) -
(log((1/pi[1])-1) /0.2031 ) },	geom="line" )
}
multiplot(plist[[1]],plist[[2]],plist[[3]])
plist[[1]]
nn.fit<-glm(y~.,data = nn, family = "binomial")
logclass<-cbind(nn,predict(nn.fit,type="response"))
pi<-c(.25, .5, .75);plist<-list()
for( i in 1:3){
logclass$yhat<-ifelse( logclass[,4] < pi[i] , 0,1)
p <- ggplot(logclass, aes(x1, x2)) + geom_point(aes(colour = factor(yhat)))
plist[[i]]<- p +	stat_function(fun=function(x){ -(0.2447 /0.2031 ) -(0.0186*x/0.2031 ) -
(log((1/pi[i])-1) /0.2031 ) },	geom="line" )
}
multiplot(plist[[1]],plist[[2]],plist[[3]])
nn.fit
nn.fit<-glm(y~.,data = nn, family = "binomial")
logclass<-cbind(nn,predict(nn.fit,type="response"))
pi<-.5
logclass$yhat<-ifelse( logclass[,4]> pi , 0,1)
p1 <- ggplot(logclass, aes(x1, x2)) + geom_point(aes(colour = factor(yhat))) +
stat_function(fun=function(x){ -(0.2447 /0.2031 ) -(0.0186*x/0.2031 ) -
(log((1/pi)-1) /0.2031 ) },	geom="line" , color = "black")
pi<-.6
logclass$yhat<-ifelse( logclass[,4]> pi , 0,1)
p2 <- ggplot(logclass, aes(x1, x2)) + geom_point(aes(colour = factor(yhat))) +
stat_function(fun=function(x){ -(0.2447 /0.2031 ) -(0.0186*x/0.2031 ) -
(log((1/pi)-1) /0.2031 ) },	geom="line" , color = "black")
pi<-.65
logclass$yhat<-ifelse( logclass[,4]> pi , 0,1)
p3 <- ggplot(logclass, aes(x1, x2)) + geom_point(aes(colour = factor(yhat))) +
stat_function(fun=function(x){ -(0.2447 /0.2031 ) -(0.0186*x/0.2031 ) -
(log((1/pi)-1) /0.2031 ) },	geom="line" , color = "black")
multiplot(p1,p2,p3)
p1
p2
p3
pi<-.5
logclass$yhat<-ifelse( logclass[,4]> pi , 0,1)
p1 <- ggplot(logclass, aes(x1, x2)) + geom_point(aes(colour = factor(yhat))) +
stat_function(fun=function(x){ -(0.2447 /0.2031 ) -(0.0186*x/0.2031 ) -
(log((1/pi)-1) /0.2031 ) },	geom="line" , color = "black")
p1
pi<-.6
logclass$yhat<-ifelse( logclass[,4]> pi , 0,1)
p2 <- ggplot(logclass, aes(x1, x2)) + geom_point(aes(colour = factor(yhat))) +
stat_function(fun=function(x){ -(0.2447 /0.2031 ) -(0.0186*x/0.2031 ) -
(log((1/pi)-1) /0.2031 ) },	geom="line" , color = "black")
p2
pi<-.65
logclass$yhat<-ifelse( logclass[,4]> pi , 0,1)
p3 <- ggplot(logclass, aes(x1, x2)) + geom_point(aes(colour = factor(yhat))) +
stat_function(fun=function(x){ -(0.2447 /0.2031 ) -(0.0186*x/0.2031 ) -
(log((1/pi)-1) /0.2031 ) },	geom="line" , color = "black")
p3
multiplot(p1,p2,p3)
p1;p2;p3
p1
p1
p2
p3
pi<-.5
logclass$yhat<-ifelse( logclass[,4]> pi , 0,1)
p1 <- ggplot(logclass, aes(x1, x2)) + geom_point(aes(colour = factor(yhat))) +
stat_function(fun=function(x){ -(0.2447 /0.2031 ) -(0.0186*x/0.2031 ) -
(log((1/pi)-1) /0.2031 ) },	geom="line" , color = "black")
pi<-.6
logclass$yhat<-ifelse( logclass[,4]> pi , 0,1)
p2 <- ggplot(logclass, aes(x1, x2)) + geom_point(aes(colour = factor(yhat))) +
stat_function(fun=function(x){ -(0.2447 /0.2031 ) -(0.0186*x/0.2031 ) -
(log((1/pi)-1) /0.2031 ) },	geom="line" , color = "black")
pi<-.65
logclass$yhat<-ifelse( logclass[,4]> pi , 0,1)
p3 <- ggplot(logclass, aes(x1, x2)) + geom_point(aes(colour = factor(yhat))) +
stat_function(fun=function(x){ -(0.2447 /0.2031 ) -(0.0186*x/0.2031 ) -
(log((1/pi)-1) /0.2031 ) },	geom="line" , color = "black")
p1
logclass$yhat<-ifelse( logclass[,4]> .5 , 0,1)
pi<-.6
logclass$yhat<-ifelse( logclass[,4]> .6 , 0,1)
pi<-.65
logclass$yhat<-ifelse( logclass[,4]> .65 , 0,1)
p1
p1
p1, p2, p3, p4,  cols=2
p4
```{r}
nn.fit<-glm(y~.,data = nn, family = "binomial")
logclass<-cbind(nn,predict(nn.fit,type="response"))
logclass$yhat<-ifelse( logclass[,4]> .5 , 0,1)
p1 <- ggplot(logclass, aes(x1, x2)) + geom_point(aes(colour = factor(yhat))) +
stat_function(fun=function(x){ -(0.2447 /0.2031 ) -(0.0186*x/0.2031 ) -
(log((1/.5)-1) /0.2031 ) },	geom="line" , color = "black")
logclass$yhat<-ifelse( logclass[,4]> .6 , 0,1)
p2 <- ggplot(logclass, aes(x1, x2)) + geom_point(aes(colour = factor(yhat))) +
stat_function(fun=function(x){ -(0.2447 /0.2031 ) -(0.0186*x/0.2031 ) -
(log((1/.55)-1) /0.2031 ) },	geom="line" , color = "black")
logclass$yhat<-ifelse( logclass[,4]> .55 , 0,1)
p3<- ggplot(logclass, aes(x1, x2)) + geom_point(aes(colour = factor(yhat))) +
stat_function(fun=function(x){ -(0.2447 /0.2031 ) -(0.0186*x/0.2031 ) -
(log((1/.6)-1) /0.2031 ) },	geom="line" , color = "black")
logclass$yhat<-ifelse( logclass[,4]> .65 , 0,1)
p4 <- ggplot(logclass, aes(x1, x2)) + geom_point(aes(colour = factor(yhat))) +
stat_function(fun=function(x){ -(0.2447 /0.2031 ) -(0.0186*x/0.2031 ) -
(log((1/.65)-1) /0.2031 ) },	geom="line" , color = "black")
multiplot(p1, p2, p3, p4,  cols=2)
p1
p2
p3
p4
P
logfun<-function(x,P){ -(0.2447 /0.2031 ) -(0.0186*x/0.2031 ) -
(log((1/P)-1) /0.2031 ) }
nn.fit<-glm(y~.,data = nn, family = "binomial")
logclass<-cbind(nn,predict(nn.fit,type="response"))
logclass$yhat<-ifelse( logclass[,4]> .5 , 0,1)
logfun<-function(x,P){ -(0.2447 /0.2031 ) -(0.0186*x/0.2031 ) -
(log((1/P)-1) /0.2031 ) }
p1 <- ggplot(logclass, aes(x1, x2)) + geom_point(aes(colour = factor(yhat))) +
stat_function(fun=logfun(x,.5),	geom="line" , color = "black") + ggtitle("p = 0.5")
sqrt(2.4)
sqrt(58)
runif(27,-1,1)
nn
women
womens
womens<-tab[which(tab$gender == 0 ),]
1-pchisq(600,43)
1/(0.5019 - 1.96 * 0.0387)
1/(0.5019 + 1.96 * 0.0387)
nb.fit<-glm.nb(response ~ gender, weights=counts, data=dat)
summary(nb.fit)
library(MASS)
summary(nb.fit)
library(MASS)
nb.fit<-glm.nb(response ~ gender, weights=counts, data=dat)
setwd("G:\\math\\661")
dat<-read.csv("sex.csv")
dat<-data.frame(
(rep(dat$Response,2)),
c(dat$Male,dat$Female),
as.factor(c(rep(1,nrow(dat)),rep(0,nrow(dat))))	)
names(dat)<-c("response","counts","gender")
str(dat)
cbind(head(dat) ,tail(dat))
library(MASS)
nb.fit<-glm.nb(response ~ gender, weights=counts, data=dat)
summary(nb.fit)
#females
exp(1.45936)
#males
exp(1.45936+0.30850)
1/(0.5019 - 1.96 * 0.0387)
#females
exp(1.45936)
#males
exp(1.45936+0.30850)
4.303205 + 1/(0.5019) * 4.303205 ^2
5.858303 + 1/(0.5019) * 5.858303 ^2
library(AER)
install.packages("AER"")
install.packages("AER)
install.packages("AER")
install.packages("AER")
install.packag
require("AER")
require("AER")
UGdat<-as.data.frame(lapply(dat, function(x,p) rep(x,p), dat[["counts"]]))
dispersiontest(dat.fit)
1-pchisq(600.60,43)
1-pchisq(600.60,43)
suppressWarnings(suppressMessages(library(pscl)))
fit.zip = zeroinfl(response ~ gender |  1 ,data=UGdat)
UGdat<-as.data.frame(lapply(dat, function(x,p) rep(x,p), dat[["counts"]]))
dat<-read.csv("sex.csv")
dat<-data.frame(
(rep(dat$Response,2)),
c(dat$Male,dat$Female),
as.factor(c(rep(1,nrow(dat)),rep(0,nrow(dat))))	)
names(dat)<-c("response","counts","gender")
str(dat)
cbind(head(dat) ,tail(dat))
UGdat<-as.data.frame(lapply(dat, function(x,p) rep(x,p), dat[["counts"]]))
fit.zip = zeroinfl(response ~ gender |  1 ,data=UGdat)
summary(fit.zip )
#mixing proportions
phi=as.numeric( exp(coef(fit.zip)[3])/(1+exp(coef(fit.zip)[3])) )
phi;1-phi
install.packages("emojifont")
library(emojifont)
library(emojifont)
install.packages("devtools")
devtools::install_github("GuangchuangYu/emojifont")
library(emojifont)
set.seed(123)
x <- rnorm(10)
set.seed(321)
y <- rnorm(10)
plot(x, y, cex=0)
text(x, y, labels=emoji('cow'), cex=1.5, col='steelblue', family='EmojiOne')
set.seed(123)
x <- rnorm(10)
set.seed(321)
y <- rnorm(10)
plot(x, y, cex=0)
text(x, y, labels=emoji('cow'), cex=1.5, col='steelblue', family='EmojiOne')
text(x, y, labels=emoji('cow'), cex=1.5, col='steelblue', family='EmojiOne')
library(showtext)
install.packages("showtext")
install.packages("showtext")
library(showtext)
text(x, y, labels=emoji('cow'), cex=1.5, col='steelblue', family='EmojiOne')
library(emojifont)
text(x, y, labels=emoji('cow'), cex=1.5, col='steelblue', family='EmojiOne')
text(x, y, labels=emoji('cow'), cex=1.5, col='steelblue', family='EmojiOne')
library(emojifont)
plot( ( smokers.fit$linear.predictors[1:5] )  - log(smokers$PersonYears)[1:5],
ylim=c(-8,-3.75) )
tab<-cbind(dat[which(dat$gender == 0),],dat[which(dat$gender == 1 ),-1])
setwd("G:\\math\\661")
dat<-read.csv("sex.csv")
dat<-data.frame(
(rep(dat$Response,2)),
c(dat$Male,dat$Female),
as.factor(c(rep(1,nrow(dat)),rep(0,nrow(dat))))	)
names(dat)<-c("response","counts","gender")
str(dat)
cbind(head(dat) ,tail(dat))
dat.fit<-glm(response ~ gender, family=poisson, weights=counts, data=dat)
summary(dat.fit)
tab<-cbind(dat[which(dat$gender == 0),],dat[which(dat$gender == 1 ),-1])
tab<-tab[,c(1,2,4)];tab[19,2]<-sum(tab[19:nrow(tab),2]);
tab[19,3]<-sum(tab[19:nrow(tab),3]);tab<-tab[1:19,]
names(tab)[2:3]<-c("Female","Male")
head(tab)
c(sum(tab[,2]),sum(tab[,1]*tab[,2]));    sum(tab[,1]*tab[,2])/sum(tab[,2])
sum( tab[,2]*((tab[,1]- 4.183871 )^2) ) / ( sum(tab[,2]) -1)
c(sum(tab[,3]),sum(tab[,1]*tab[,3]));    sum(tab[,1]*tab[,3])/sum(tab[,3])
sum( tab[,3]*((tab[,1]- 4.183871 )^2) ) / ( sum(tab[,3]) -1)
1-pchisq(3985.7,43)
tab<-cbind(dat[which(dat$gender == 0),],dat[which(dat$gender == 1 ),-1])
tab<-tab[,c(1,2,5)]
names(tab)[2:3]<-c("Female","Male");head(tab)
sex.n = by(dat$counts, dat$gender, sum)
sex.nb = glm.nb(response ~ gender, weights=counts, data=dat)
dat[which(dat$gender == 0),],dat[which(dat$gender == 1 ),-1]
dat
dat
dat
dat[which(dat$gender == 0),]
datt
tab
dat
tab<-cbind(dat[which(dat$gender == 0),],dat[which(dat$gender == 1 ),-1])
tab
sex.nb$theta
set.seed(504)
# I'll make a random network where each edge exists with probability .6,
# Hopefully all nodes will be connected, we'll check.
library(igraph)
# create random adjacency matrix
random_m <- matrix(as.numeric(runif(5^2) < .6), nrow=5, ncol=5)
# remove diagnal
for (i in 1:5)
random_m[i,i] <- 0
# create graph and visually check
g <- graph_from_adjacency_matrix(random_m)
plot(g)
# turn adjacency matrix into a transition probability matrix
A <- random_m/rowSums(random_m)
A
A
# turn adjacency matrix into a transition probability matrix
A <- random_m/rowSums(random_m)
A
# routine to compute power iteration
simult_iteration <- function(A, V, tol=10^-6)
{
iter <- 1
repeat {
prev_V <- V
V <- A %*% V
V <- qr.Q(qr(V))
diff <- as.numeric(V - prev_V)
if (sum(abs(diff)) < tol)
break
iter <- iter + 1
}
# diagnoal entries of V^T A V gives rayleight quotients
rayleigh <- diag(t(V) %*% A %*% V)
list(V=V, lambda=rayleigh, iterations=iter)
}
setwd("G:\\math\\504")
votes <- read.table("votes_formatted.txt", header=T, stringsAsFactors = F)
senators <- read.table("senators_formatted.txt", header=T, stringsAsFactors = F)
getwd()
votes <- read.table("votes_formatted.txt", header=T, stringsAsFactors = F)
senators <- read.table("senators_formatted.txt", header=T, stringsAsFactors = F)
X <- t(as.matrix(votes[,-1]))
M <- t(X) %*% X
# routine to compute power iteration
power_iteration <- function(A, v, tol=10^-6)
{
iter <- 1
repeat {
prev_v <- v
v <- A %*% v
v <- v/sum(v)
diff <- v - prev_v
if (sum(abs(diff)) < tol)
break
iter <- iter + 1
}
rayleigh <- t(v) %*% A %*% v/sum(v*v)
list(v=v, lambda=rayleigh, iterations=iter)
}
dominant_info <- power_iteration(M, rep(1,542))
q <- dominant_info$v
# project
coor_proj1 <- as.numeric(X %*% q)
# plot, I use ggplot2's qplot, great package to know
library(ggplot2, quietly = T)
qplot(x=coor_proj1, y=0, color=senators$party)
# routine to compute power iteration
simult_iteration <- function(A, V, tol=10^-6)
{
iter <- 1
repeat {
prev_V <- V
V <- A %*% V
V <- qr.Q(qr(V))
diff <- as.numeric(V - prev_V)
if (sum(abs(diff)) < tol)
break
iter <- iter + 1
}
# diagnoal entries of V^T A V gives rayleight quotients
rayleigh <- diag(t(V) %*% A %*% V)
list(V=V, lambda=rayleigh, iterations=iter)
}
# create arbitrary values of 2 initil vectors then
# execute simultaneous iteration
V <- diag(nrow(M))[,1:2]
V
dim(V)
dim(M)
Q
votes <- read.table("votes_formatted.txt", header=T, stringsAsFactors = F)
senators <- read.table("senators_formatted.txt", header=T, stringsAsFactors = F)
X <- t(as.matrix(votes[,-1]))
M <- t(X) %*% X
# routine to compute power iteration
power_iteration <- function(A, v, tol=10^-6)
{
iter <- 1
repeat {
prev_v <- v
v <- A %*% v
v <- v/sum(v)
diff <- v - prev_v
if (sum(abs(diff)) < tol)
break
iter <- iter + 1
}
rayleigh <- t(v) %*% A %*% v/sum(v*v)
list(v=v, lambda=rayleigh, iterations=iter)
}
dominant_info <- power_iteration(M, rep(1,542))
q <- dominant_info$v
# project
coor_proj1 <- as.numeric(X %*% q)
# plot, I use ggplot2's qplot, great package to know
library(ggplot2, quietly = T)
qplot(x=coor_proj1, y=0, color=senators$party)
# routine to compute power iteration
simult_iteration <- function(A, V, tol=10^-6)
{
iter <- 1
repeat {
prev_V <- V
V <- A %*% V
V <- qr.Q(qr(V))
diff <- as.numeric(V - prev_V)
if (sum(abs(diff)) < tol)
break
iter <- iter + 1
}
# diagnoal entries of V^T A V gives rayleight quotients
rayleigh <- diag(t(V) %*% A %*% V)
list(V=V, lambda=rayleigh, iterations=iter)
}
# create arbitrary values of 2 initil vectors then
# execute simultaneous iteration
V <- diag(nrow(M))[,1:2]
dim(V)
dim(M)
dominant_info <- simult_iteration(M, V)
Q <- dominant_info$V
# create projections and plot
proj <- X %*% Q
qplot(x=proj[,1], y=proj[,2], color=senators$party,
xlab="component 1", ylab="component 2")
dim(X);dim(Q)
head(senators)
votes
dim(votes)
dim(X);dim(Q)
nn.fit<-glm(y~.,data = nn, family = "binomial")
nn<-read.table("nn.txt",header=T)
nn.fit<-glm(y~.,data = nn, family = "binomial")
logclass<-cbind(nn,predict(nn.fit,type="response"))
predict(nn.fit,type="response")
glm(y~.,data = nn, family = "binomial")
